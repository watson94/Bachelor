%-*-coding: utf-8-*-
\chapter{Практическая реализация алгоритма}

В рамках данной работы была написана утилита для поиска корректно-синхронизированных полей, использующая алгоритм из предыдущего раздела. Программа написана на языке программирования java и интегрирована с jDRD.

\FloatBarrier
\section{Особенности реализации}
Данная программа имеет два режима работы: \emph{локальный} и \emph{локальный}. \emph{Локальный} режим подразумевает, что анализируемый код
может использоваться строронними приложениями, не входящими в область анализа. Таким образом, если поле корректно-синхронизированно в рамках анализируемой программы, но оно доступно для изменения, то в локальном режиме оно не считается корректно-сихронизированным. Такой режим нужен для анализа различных библиотек. \emph{Глобальный} режим подразумевает, что 
анализируемый код, никем используется. Если поле корректно-синхронизированно в рамках анализируемой программы, то даже если оно доступно для изменения, глобальный режим отметит отметит его как корректно-синхронизированное. Данный режим необходим для тестирования законченых приложений. Множество переменных, выделенных в глобальном режиме включает в себя множество, выделенное при работе в локальном режиме.



В листинге \ref{Account} поле $balance$, корректно-синхронизирован и будет выделено при работе программы и в локальном и в глобальном режиме. Если убрать модификатор $private$ у поля $balance$ и предположить, что в рамках программы снаружи к полю
$balance$ не обращаются, то оно будет корректно-синхронизировано только с точки зрения глобального режима.

\lstinputlisting[caption=Пример корректно-синхронизированного поля для локального режима, language=Java, label=Account]{code/Account.java}

Программа на вход принимает скомпилированные фалйы java программ. На вход ей можно подать либо $jar$-файл с программой либо указать путь до папки с $class$-файлами.  Промежутончое представление и граф потока исполнения получено на основе байт-кода с помощью библиотеки $Soot$. Промежуточное представление используемое в данной работе для анализа называется $Shimple$.


\FloatBarrier
\section{Тестирование}
Было проведено тестирование данной программы на различных тестах. Создан набор тестов, покрывающий большинство конструкций java программ. В качестве тестов были использованы программы использующие различные операции синхронизации, обработку ошибок(exception), статические и нестатические блокировки и поля, внутренние классы и т.д.

Также были проведены запуски на реальных библиотеках и приложениях с последующей проверкой результатов.

\FloatBarrier
\section{Сбор статистики и интеграция с jDRD}
В программу статического анализа был добавлен модуль сбора статистики, который подсчитывает различные метрики работы алгоритма. Этот модуль необходим для оценивания результата работы программы.

jDRD получает список корректно-синхронизированных полей через конфигурационный файл, генерируемый разработанной программой.
На стороне jDRD был также включен сбор статистики, который отслеживает количество обращений к корректно-синхронизированным полям, выделенным статическим анализом.


\section{Полученные результаты}
Программа была запущена на различных приложениях, которые активно используют конкурентный доступ к данным .  Результаты приведены в таблице. 

\begin{table}[H]
\label{results}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Приложение & Общее количество полей & Корректно-синхронизированных полей & Процент \\
\hline
dxFeed & 5730 & 493 & 8,6 \\
\hline
MARS & 4437 & 340 & 7,6 \\
\hline
Tomcat & 7600 & 390 & 5,1 \\

\hline

\end{tabular}
\captionsetup{justification=centering}
\caption{Полученные результаты}
\end{center}
\end{table}
Далее представлено краткое описание тестируемых библиотек.
\\MARS(Monitoring and reporting system) --- Система мониторинга реального времени. Используется для отображения различных данных приложения. 
\\ dxFeed --- система, отвечающая за быструю доставку больших данных(котировок).
\\ Tomcat --- контейнер сервлетов. Позволяет запускать веб-приложения.

По результатам видно, что для данных библиотек  в среднем статическим анализом можно обнаружить около

Далее приведены найденные часто используемые паттерны, применяемые для защиты блокировкой операций блокировкой.
\\
\\
\\
\\
\lstinputlisting[caption=Использование syncronized методов, language=Java, label=Pattern1]{code/Pattern1.java}
\lstinputlisting[caption=Использование блокировки для синхронизации, language=Java, label=Pattern2]{code/Pattern2.java}
\lstinputlisting[caption=Использование блокировки для синхронизации, language=Java, label=Pattern3]{code/Pattern3.java}

\FloatBarrier
