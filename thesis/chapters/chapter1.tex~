%-*-coding: utf-8-*-
\chapter{Обзор}
\label{chapSVD}

В первом разделе главы рассмотрены различные подходы к поиску гонок, оценены их возможности, преимущества и недостатки. 
Во втором модель памяти Java, динамический детектор для Java программ и возможности для его улучшения статическим анализом.
Автоматические подходы к обнаружению гонок и сам динамический детектор более подробно описаны в \cite{DRD}.
В третьем разделе рассмотрены основные возможности и подходы статического анализа для решения исходной задачи.


\FloatBarrier
\section{Методы автоматического обнаружения гонок}
\subsection{Статический подход}
Статический анализ требует только исходный код или скомпилированные файлы. Для проведения анализа не требуется запуск программы. Но задача обнаружения гонок статическим анализом является NP-трудной. Поэтому статически выявить гонки за приемлимое время невозможно. Существующие утилиты используют различные эвристики, уменьшают глубину анализа, что приводит к существенно неточным и неполным результатам, а также допускают ложные срабатывания.
Подводя итог, отметим основные преимущества и недостатки статического подхода. К преимуществам относится то, что в отличии от динамического подхода, теоретически возможен анализ всех участков программы, а также то, что статический подход не требует запуска программы и не наносит ущерб ее выполнению. Главным и существенным недостатком является
пропуск большого числа гонок, а также ложные срабатывания.


\subsection{Динамический подход}
Динамические детекторы выполняются одновременно с программой и отслеживают синхронизационные события и обращения к разделяемым переменным. Среди динамических детекторов выделяют 2 вида : 
\begin{itemize}
\item on-the-fly - получают информацию и анализируют её во время выполнения программы.
\item post-mortem - сохраняют информацию во время выполнения программы, а анализируют её уже
после завершения работы программы.
\end{itemize}
Динамический анализ является неполным, так как анализируется только конкретный путь исполнения программы. Однако теоретически он гарантирует тончость, то есть отсутствие ложных срабатываний. 

Для динамического анализа используются два принципиально различных алгоритма : $happens$-$before$ и $lockset$, которые описаны в [1,2,3].


\FloatBarrier
\section{Динамический детектор гонок для java программ}

\FloatBarrier
\subsection{Модель памяти java}
Для языка программирования java существует спецификация его модели памяти(Java memory model), которая входит в стандарт языка. Данная спецификация содержит архитектурно-независимые гарантии исполнения многопоточных программ.
Для загрузки изменений из памяти потока в общую память программы, а также для загрузки чужих изменений из общей памяти программы в память потока есть операции синхронизации. В JMM описано отношение $happens$-$before$. Если операция $A\ happens$-$before\ B$, то при выполнении операции $B$ видны изменения, выполненые $A$. Если операции $A$ и $B$ происходят из разных потоков и обращаются к одному участку памяти, то они не образуют гонку тогда и только тогда, когда $A$ $happens$-$before$ $B$ либо $B$ $happens$-$before$ $A$.



\subsection{Динамический детектор jDRD}
jDRD --- динамический детектор для java программ. Он основан на $happens$-$before$ алгоритме. 

Рассмотрим подробнее $happens$-$before$ алгоритм, чтобы выявить места для ускорения jDRD.

Для каждого потока $t$ будут храниться векторные часы $t.vc$. Также часы будут храниться для всех разделяемых переменных $v.vc$ и синхронизационных объектов $l.vc$.
Векторные часы являются массивом целых чисел, каждая компонента которого является целым числом, отвечающим за компоненту часов соответсвующего потока. Векторные часы имеют длину равную общему количеству потоков. Каждый поток хранит свою локальную копию векторных часов, синхронизируясь с копиями часов других потоков во время синхронизационных операций.
Сравнение часов происходит при обращениях к разделяемых переменных.
\\Изначально:  

\begin{itemize}
	\item $ \forall i:\ t_i.vc[i]\ :=\ 1$
	\item $ \forall i,\ j\ \neq i:\ t_i.vc[j] := 0$
	\item $ \forall v,\ j:\  v.vc[j]\ :=\ 0$
	\item $ \forall l,\ j:\  l.vc[j]\ :=\ 0$
\end{itemize}
При захвате потоком $t$ синхранизационного объекта $l$: 

\begin{itemize}
	\item $ \forall j:\ t.vc[j] = max(t.vc[j]\ , l.vc[j])$
\end{itemize}
При освобождении потоком $t_i$ синхранизационного объекта $l$: 

\begin{itemize}
	\item $t_i.vc[i]$++
	\item $ \forall j:\ l.vc[j] = max(l.vc[j]\ , t_i.vc[j])$
\end{itemize}
При обращении потока $t$ к разделяемой переменной $v$: 
\begin{itemize}
	\item Если $ \exists j:\ v.vc[j]\ >\ t.vc[j]$, то значит найдена гонка. 
	\item $v.vc$ = $t.vc$
\end{itemize}


В случае java программ данными разделяемыми переменными являются поля. 


\subsection{Возможности статического анализа для оптимизации jDRD}
Как видно из описания работы jDRD, каждое поле является потенциальным местом возникновения гонки.  
Для каждого поля в jDRD приходится хранить векторные часы. Статическим анализом можно выяснить, что некоторые поля $корректо-синхронизированы$ - то есть, при обращении к ним невозможно состояние гонки. Это позволит уменьшить потребление памяти и времени детектора. 

\section{Статический анализ для поиска корректно-синхронизированных полей}

\subsection{Существующие утилиты для статического анализа}
В настоящее время существует достаточное количество утилит, которые производят статический анализ. Немногие из них, такие как $FindBugs$ и $ThreadSafe$ ориентированы на анализ конкурентного доступа к данным. Но все эти утилиты ориентированы на поиск ошибок в программах и для решения исходной задачи не подходят.
Существуют утилиты, которые статическим анализом позволяют получать различные представления исходного кода для дальнейшего анализа. Такие утилиты не могут решить исходную задачу, но могут быть использованы, как вспомогательные в данной работе. 
Таким образом, задача поиска корректно-сихронизированных полей статическим анализом актуальна, и в открытом доступе нет утилиты, позволяющей решать данную задачу. 
\subsection{Возможные подходы к анализу}
Основным объектом исследования при статическом анализе программ является граф потока исполнения выполнения. 
\\\emph{Граф потока исполнения\ (англ. control flow graph,\ CFG)} --- все возможные пути исполнения части программы, представленые в виде графа. Вершинами данного графа являются последовательности операций, не содержащие в себе ни операций передачи управления, ни точек, на которые управление передается из других частей программы. Ребра показывают возможные переходы между операциями.
Построение данных графов зависит от представления программы, которое используется. Для java программ изначально 
доступно представление в виде байт-кода. Если доступен исходный код, то можно проводить анализ самой java программы.
Данные представления неудобны для последующего анализа. Байт-код имеет большое количество инструкций.  Java код имеет большое количество синтаксических конструкций, все из которых трудно проанализировать. Поэтому, часто оказываются удобными для анализа промежуточные представления.
\\\emph{Промежуточное представление (англ. Intermediate representation, IR)} --- язык абстрактной машины, упрощающий проведение анализа. Для java программ большинство промежуточных представлений строится на основе байт-кода.

В данной работе будут искаться поля, обращения к которым всегда защищены блокировкой. В качестве блокировок будут рассмотрены стандартные операции захвата и освобождения монитора, а также блокировки пакета java.util.concurrent.


Не рассмотреной в данной работе ост
\FloatBarrier
