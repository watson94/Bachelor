%-*-coding: utf-8-*-
\chapter{Обзор}
\label{chapSVD}

В первом разделе главы рассмотрены различные подходы к поиску гонок, оценены их возможности, преимущества и недостатки. 
Во втором --- модель памяти Java, динамический детектор для Java программ и возможности для его оптимизации статическим анализом.
Автоматические подходы к обнаружению гонок и сам динамический детектор более подробно описаны в \cite{DRD}.
В третьем разделе рассмотрены основные возможности и подходы статического анализа для решения исходной задачи.


\FloatBarrier
\section{Методы автоматического обнаружения гонок}
\subsection{Статический подход}
\label{StaticRaceDetection}
Статический анализ требует только исходный код или скомпилированные файлы. Для проведения анализа не требуется запуск программы. Но задача обнаружения гонок статическим анализом является NP-трудной \cite{RaceDetectionReview, RaceDetection}. Поэтому статически выявить гонки за приемлемое время невозможно. Существующие реализации используют различные эвристики, уменьшают глубину анализа, что приводит к существенно неточным и неполным результатам, а также допускают ложные срабатывания. Существуют программы,!!!!!. Одной из наиболее эффективных существующих реализаций является Chord\cite{Chord, JChord}.
 С существующими подходами и реализациями можно ознакомиться в \cite{Naik:2006:ESR:1133255.1134018, RacerX}.

Подводя итог, отметим основные преимущества и недостатки статического подхода. К преимуществам относится то, что в отличии от динамического подхода, теоретически возможен анализ всех участков программы, а также то, что статический подход не требует запуска программы и не использует ресурсы во время её выполнения. Главным и существенным недостатком является
пропуск большого числа гонок, а также ложные срабатывания. 


\subsection{Динамический подход}
Динамические детекторы выполняются одновременно с программой и отслеживают синхронизационные события и обращения к разделяемым данным. Среди динамических детекторов выделяют 2 вида: 
\begin{itemize}
\item on-the-fly --- получают информацию и анализируют её во время выполнения программы \cite{Choi:2002:EPD:543552.512560};
\item post-mortem --- сохраняют информацию во время выполнения программы, а анализируют её уже
после завершения работы программы \cite{PostMortem}.
\end{itemize}
Динамический анализ является неполным, так как анализируется только конкретный путь исполнения программы. Однако теоретически он гарантирует точность, то есть отсутствие ложных срабатываний. 

Для динамического анализа используются два принципиально различных алгоритма: $happens$-$before$\cite{DRD, Happens-Before} и $lockset$\cite{DRD, LockSet, GoldiLocks}. Также существуют гибридные алгоритмы\cite{DRD, Choi:2002:EPD:543552.512560}, которые совмещают преимущества $happens$-$before$ и $lockset$ алгоритмов. 


\FloatBarrier
\section{Динамический детектор гонок для java программ}

\FloatBarrier
\subsection{Модель памяти java}
Для языка программирования java существует спецификация его модели памяти (Java memory model, JMM), которая входит в стандарт языка. Данная спецификация содержит архитектурно-независимые гарантии исполнения многопоточных программ.
Для загрузки изменений из памяти потока в общую память программы, а также для загрузки чужих изменений из общей памяти программы в память потока существуют операции синхронизации. В JMM описано отношение $happens$-$before$. Если операция $A\ happens$-$before\ B$, то в момент начала выполнения операции $B$ видны изменения, выполненные $A$. Если операции $A$ и $B$ выполняются из разных потоков и обращаются к одному участку памяти, то они не образуют гонку тогда и только тогда, когда $A$ $happens$-$before$ $B$ либо $B$ $happens$-$before$ $A$ \cite{JMM}.



\subsection{Динамический детектор jDRD}
jDRD --- динамический детектор гонок для java-программ. Он основан на $happens$-$before$ алгоритме \cite{DRD}. 

Рассмотрим подробнее $happens$-$before$ алгоритм, чтобы выявить места для ускорения jDRD.

Для каждого потока $t$ будут храниться векторные часы $t.vc$. Также часы будут храниться для всех разделяемых переменных $v.vc$ и синхронизационных объектов $l.vc$.
Векторные часы являются массивом целых чисел, каждая компонента которого является целым числом, отвечающим за компоненту часов соответствующего потока. Векторные часы имеют длину, равную общему количеству потоков. Каждый поток хранит свою локальную копию векторных часов, синхронизируясь с копиями часов других потоков во время синхронизационных операций.
Сравнение часов происходит при обращениях к разделяемым переменным.
\\Изначально:  

\begin{itemize}
	\item $ \forall i:\ t_i.vc[i]\ :=\ 1$
	\item $ \forall i,\ j\ \neq i:\ t_i.vc[j] := 0$
	\item $ \forall v,\ j:\  v.vc[j]\ :=\ 0$
	\item $ \forall l,\ j:\  l.vc[j]\ :=\ 0$
\end{itemize}
При захвате потоком $t$ синхронизационного объекта $l$: 

\begin{itemize}
	\item $ \forall j:\ t.vc[j] := max(t.vc[j]\ , l.vc[j])$
\end{itemize}
При освобождении потоком $t_i$ синхронизационного объекта $l$: 

\begin{itemize}
	\item $t_i.vc[i]$++
	\item $ \forall j:\ l.vc[j] := max(l.vc[j]\ , t_i.vc[j])$
\end{itemize}
При обращении потока $t$ к разделяемой переменной $v$: 
\begin{itemize}
	\item Если $ \exists j:\ v.vc[j]\ >\ t.vc[j]$, то значит найдена гонка. 
	\item $v.vc$ $:=$ $t.vc$
\end{itemize}


В случае java-программ данными разделяемыми переменными являются поля. 


\subsection{Возможности статического анализа для оптимизации jDRD}
Как видно из описания работы jDRD, каждое поле является потенциальным местом возникновения гонки.  
Для каждого поля в jDRD приходится хранить векторные часы. Статическим анализом можно выяснить, что некоторые поля корректно-синхронизированы --- то есть, при обращении к ним невозможно состояние гонки. Это позволит ускорить динамический детектор и уменьшить его потребление памяти. 

\section{Статический анализ для поиска корректно-синхронизированных полей}

\subsection{Существующие возможности статического анализа}
В настоящее время статический анализ рассмотрен довольно широко.
В разделе \ref{StaticRaceDetection} были рассмотрены статические детекторы гонок. Существует достаточное количество программ, которые проводят статический анализ для различных целей. Немногие из них, такие как $FindBugs$\cite{FindBugs} и $ThreadSafe$, проводят анализ конкурентного доступа к данным. Но все эти инструменты ориентированы на поиск ошибок в программах и для решения исходной задачи не подходят.
Существуют реализации, которые статическим анализом позволяют получать различные представления исходного кода для дальнейшего анализа. Такие программы не могут решить исходную задачу, но могут быть использованы, как вспомогательные в данной работе. 
Таким образом, задача поиска корректно-синхронизированных полей статическим анализом актуальна, и в открытом доступе нет программы, позволяющей решать данную задачу. 
\subsection{Возможные подходы к анализу}
Объектами исследования при статическом анализе программ являются различные графы(граф потока исполнения, граф использования объектов, $point$-$to$ граф\cite{Whaley:1999:CPE:320385.320400}). 
В данной работе проводится анализ графа потока исполнения. 
\\\emph{Граф потока исполнения\ (англ. control flow graph,\ CFG)} --- это все возможные пути исполнения части программы, представленные в виде графа. Вершинами данного графа являются последовательности операций, не содержащие в себе ни операций передачи управления, ни точек, на которые управление передается из других частей программы. Ребра показывают возможные переходы между операциями.
Построение данных графов зависит от представления программы, которое используется. Для java-программ изначально 
доступно представление в виде байт-кода. Если доступен исходный код, то можно проводить анализ самой java-программы.
Данные представления неудобны для последующего анализа. Байт-код имеет большое количество инструкций. Java-код имеет большое количество синтаксических конструкций, которые трудно проанализировать. Поэтому часто оказываются удобными для анализа промежуточные представления.
\\\emph{Промежуточное представление (англ. Intermediate representation, IR)} --- язык абстрактной машины, упрощающий проведение анализа. Для java-программ большинство промежуточных представлений строится на основе байт-кода.

В данной работе выделены поля, обращения к которым всегда защищены блокировкой. В качестве блокировок рассмотрены стандартные операции захвата и освобождения монитора, а также блокировки пакета java.util.concurrent.


Не рассмотрен в данной работе другой возможный подход к выделению корректно-синхронизированных полей.
Статическим анализом можно пытаться доказать, что переменная не покидает контекст одного потока. То есть, если можно статически доказать, что все обращения к полю происходят только в рамках одного потока, то данное поле корректно-синхронизировано\cite{Whaley:1999:CPE:320385.320400}.
\FloatBarrier
