%-*-coding: utf-8-*-
\chapter{Обзор}
\label{chapSVD}

В первом разделе главы рассмотрены различные подходы к поиску гонок, оценены их возможности, преимущества и недостатки. 
Во втором модель памяти Java, динамический детектор для Java программ и возможности для его улучшения статическим анализом.
Автоматические подходы к обнаружению гонок и сам динамический детектор более подробно описаны в \cite{DRD}.
В третьем разделе рассмотрены основные возможности и подходы статического анализа для решения исходной задачи.


\FloatBarrier
\section{Методы автоматического обнаружения гонок}
\subsection{Статический подход}
Статический анализ требует только исходный код или скомпилированные файлы. Для проведения анализа не требуется запуск программы. Но задача обнаружения гонок статическим анализом является NP-трудной. Поэтому статически выявить гонки за приемлимое время невозможно. Существующие утилиты используют различные эвристики, уменьшают глубину анализа, что приводит к существенно неточным и неполным результатам, а также допускают ложные срабатывания.
Подводя итог, отметим основные преимущества и недостатки статического подхода. К преимуществам относится то, что в отличии от динамического подхода, теоретически возможен анализ всех участков программы, а также то, что статический подход не требует запуска программы и не наносит ущерб ее выполнению. Главным и существенным недостатком является
пропуск большого числа гонок, а также ложные срабатывания.


\subsection{Динамический подход}
Динамические детекторы выполняются одновременно с программой и отслеживают синхронизационные события и обращения к разделяемым переменным. Среди динамических детекторов выделяют 2 вида : 
\begin{itemize}
\item on-the-fly - получают информацию и анализируют её во время выполнения программы.
\item post-mortem - сохраняют информацию во время выполнения программы, а анализируют её уже
после завершения работы программы.
\end{itemize}
Динамический анализ является неполным, так как анализируется только конкретный путь исполнения программы. Однако теоретически он гарантирует тончость, то есть отсутствие ложных срабатываний. 

Для динамического анализа используются два принципиально различных алгоритма : $happens-before$ и $lockset$, которые описаны в [1,2,3].


\FloatBarrier
\section{Динамический детектор гонок для Java программ}
\FloatBarrier
\subsection{Модель памяти Java}
Для языка программирования Java существует спецификация его модели памяти(Java memory model), которая входит в стандарт языка. Данная спецификация содержит архитектурно-независимые гарантии исполнения многопоточных программ.
Для загрузки изменений из памяти потока в общую память программы, а также для загрузки чужих изменений из общей памяти программы в память потока есть операции синхронизации.



\subsection{Динамический детектор jDRD}
Описание jDRD

\subsection{Возможности статического анализа для оптимизации jDRD}
Как видно из описания работы jDRD, каждое поле является потенциальным местом возникновения гонки.  
Следовательно для каждого поля в jDRD приходится хранить векторные часы. Статическим анализом можно выяснить, что некоторые поля корректо-синхронизированы - то есть, при обращении к ним невозможно состояние гонки. Это позволит уменьшить потребление памяти и времени детектора. Также статическим анализом можно выделить корректно-синхронизированные последовательности операций - последовательность операций, которая гарантировано исполняется в одном потоке.
\section{Статический анализ для поиска корректно-синхронизированных полей}

\subsection{Существующие утилиты для статического анализа}
В настоящее время существует достаточное количество утилит, которые производят статический анализ. Немногие из них, такие как $FindBugs$ и $ThreadSafe$ ориентированы на анализ конкурентного доступа к данным. Но все эти утилиты ориентированы на поиск ошибок в программах и для решения исходной задачи не подходят.
Существуют утилиты, которые статическим анализом позволяют получать различные представления исходного кода для дальнейшего анализа. Такие утилиты не могут решить исходную задачу, но могут быть использованы, как вспомогательные в данной работе. 
Таким образом, задача поиска корректно-сихронизированного кода статическим анализом актуальна, и в открытом доступе нет утилиты позволяющей решать данную задачу. 
\subsection{Возможные подходы к анализу}
Основным объектом исследования при статическом анализе программ является граф выполнения (control flow graph). На его основе может быть построен граф использования объектов(object use graph).

Построение данных графов зависит от представления программы, которое используется. Для Java программ изначально 
доступно представление в виде байт-кода. Если доступен исходный код, то можно проводить анализ самой Java программы.
Данные представления неудобны для последующего анализа. Байт-код имеет большое количество инструкций.  Java код имеет большое количество синтаксических конструкций, все из которых трудно проанализировать. Поэтому, часто оказываются удобными для анализа промежуточные представления(intermediate representation).
 

\FloatBarrier
