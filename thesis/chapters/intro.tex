% -*-coding: utf-8-*-
\startprefacepage

В настоящее время все большее количество устройств становится многоядерными и многопроцессорными, и вместе с этим
приходится разрабатывать эффективные параллельные программы. Но разработка программ с несколькими потоками выполнения, является сложной и влечет большое количество ошибок. Одной из таких ошибок является состояние гонки (data race, race condition) --- несинхронизированные обращения из различных потоков к одному и тому же участку памяти, хотя бы одно из которых является обращением на запись. Состояние гонки в программах является частой допускаемой ошибкой и обнаружение  данных ошибок является сложной и актуальной задачей. 

Большинство современных языков, в том числе Java использую многопоточную модель с разделяемой памятью. Для публикации изменений, сделанных потоком, и для получения изменнений, сделанных другими потоками существуют операции синхронизации.
Контракты модели памяти описывают гарантии, которые предоставляют различные операции синхронизации. Данные операции обеспечивают упорядоченность по времени между операциями. Если между операциями нет упорядочивания по времени, и хотя бы одна операция является записью, то наступает состояние гонки.

На \ref{race-cond} показан пример программы, с разделяемой памятью, в которой возникает состояние гонки.
\drawfigurex{RaceCondition.png}{Состояние гонки в программе}{race-cond}{0.95\textwidth}
\FloatBarrier
Возможно несколько вариантов исполнения данной программы, в том числе и корректный, при котором значение переменной $s$ после исполнения двух потоков будет равно 5. Но ожидаемый результат не гарантирован. Возможный вариант исполнения программы: 
\begin{enumerate}
\item Оба потока, загружают 0 в локальные переменные.
\item Увеличивают $s$ параллельно.
\item Сохраняют, не важно в каком порядке значение $s$.
\end{enumerate}
В результате в переменной $s$ может оказаться 2 или 3. Также стоит отметить, что даже если все операции одного потока выполянтся раньше, чем первая операция другого, то корректный результат исполнения не гарантирован. Это связано с тем, что в данной программе нет никаких операций синхронизации, а следовательно нет никаких гарантий того, что изменения сделанные одним потоком будут видны другому потоку. То есть, после того как один из потоков исполнит операцию $store$, не гарантируется, что другой поток увидит изменения.

Гонки могут возникать в различных системах и наносить большой ущерб. Не синхронизировав должным образом программу, в любой финансовой системе может возникнуть проблема с балансами счетов. Простое зачисление или снятие может работать некорректно. Поймать гонку на этапе тестирования очень сложно, поскольку обычно технические характеристики и архитектура устройств, на которых тестируется и запускается программа сильно различаются. Гонку трудно отыскать, даже когда она уже произошла. Если гонка случилась, то испорченные данные могут долго распространяться по программе, и несоответствие может обнаружиться совсем в другом месте. Повторный запуск программы на тех же данных может не привести к возникновению гонки. Таким образом, задача автоматического обнаружения гонок является
сложной и актуальной.

В главе 1 будут более подробно разобраны подходы к автоматическому поиску гонок в программах. Пока, отметим, что существует два принципиально разных подхода к обнаружению гонок : статический и динамический. Статический подход  анализирует программу без ее запуска. Динамический подход работает вместе с программой и анализирует конкретный вариант работы программы. Задача нахождения гонок статическим анализом является NP-трудной. Поэтому при статическом подходе снижается точность и полнота результата. Главной проблемой динамического подхода является наносимый ущерб производительности и потребления памяти анализируемой программы. Целью данной работы является оптимизация динамического детектора путем проведения предварительного статического анализа. 

Статический анализ не наносит ущерб исполнению программы. С другой стороны, во время статического анализа можно выделить поля, при обращении к которым не может возникнуть состояние гонки(далее корректно-синхронизированные поля).

Динамический анализ использует достаточно большие структуры данных для полей и операций синхронизации. Информация о том, что часть полей можно не анализировать позволит уменьшить время анализа и объем потребляемой памяти, и следовательно уменьшить ущерб наносимый динамическим детектором.

В рамках данной работы будет разработан алгоритм для выделения корректно-синхронизированных полей и реализована соответствующая программа. Программа будет интегрирована с одним из существующих динамических детекторов.

\FloatBarrier
