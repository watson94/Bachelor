%-*-coding: utf-8-*-
\chapter{Описание алгоритма}


В данной главе будет рассмотрен алгоритм для поиска корректно-синхронизированных полей.
Поле является корректно-синхронизированным, когда существует блокировка, такая, что любая операция c полем проводится с этой блокировкой. Алгоритм будет искать для полей, такие блокировки. 
Алгоритм можно разделить на 3 части. 
\begin{enumerate}
\item Получение промежуточного представления и графа потока исполнения.
\item Получение множества возможных блокировок.
\item Обход графа потока исполнения и выделение корректно-синхронизированных полей.
\end{enumerate}

В первой главе будет рассмотренно промежуточное представление, на основе которого будет строиться граф потока исполнения. Во второй показано как выделить множество переменных, которые могут являться блокировкой. Эта часть алгоритма необходима, так как при статическом анализе не каждая локальная переменная и не каждое поле может являться потенциальной блокировкой. 
В третей части будет рассмотрена основная часть алгоритма --- обход графа потока исполнения, отслеживание и обработка и операций сихронизаций и обращений к полям, выделение корректно-синхронизированных полей.



\FloatBarrier
\section{Описание промежуточного представления и CFG для него}
Как уже говорилось ранее, существуют утилиты для получения различных промежуточных представлений и их графов потоков исполнения. 
Для данной работы было выбрано промежуточное представление приведенное в SSA форму. SSA форма технически упрощает получение множества блокировок. В промежуточном представлении используемом в данной работе, вся работа со стеком заменена на локальные переменные. Как и в байт-коде будет две примитивные операции синхронизации: $monitorEnter$ и $monitorExit$. Эти операции отвечают за взятие и освобождение монитора объекта.

Каждая переменная имеет единственное место присваивания, так как представление удовлетворяет SSA форме. 
Для присваивания переменной может использоваться $\phi$-функция.
Если локальная переменная может принимать несколько значений, то данная переменная присваивается $\phi$-функции из всех возможных ее значений. Подробнее о SSA форме и $\phi$-функциях можно прочитать в [2].
Присваивания в данном представлении удоветворяют следующей грамматике.

\begin{table}[H]
\label{tabular:timesandtenses}
\begin{center}
\begin{tabular}{|c|c|}
\hline
local & Локальная переменная \\
\hline
field & Поле \\
\hline
\multirow{2}{*}{imm}  & $local$ \\
		      & $constant$ \\
\hline
\multirow{5}{*}{expr} & $imm_1\ binop\ imm_2$ \\
		      & (type) $imm$ \\
		      & $imm_1$ instanceof type \\
      		      & invokeExpr \\
      		      & $new$ refType \\
      		      & $newarray$ (type) [imm] \\
		      & $neg\ imm$ \\
\hline
\multirow{4}{*}{assignStmt} & $local$ = $\phi$($imm_1$, $imm_2$, ...) \\ 
			    & $local$ = $imm$ | $field$ | $local.field$ | $expr$  \\ 
		            & $field$ = $imm$ \\
			    & $local.field$ = $imm$ \\
\hline
\end{tabular}
\end{center}
\caption{center}{Грамматика присваиваний используемого IR}
\end{table}


Далее будет приведен простейший пример метода, полученное промежуточное представление и его $CFG$.

\renewcommand{\lstlistingname}{}
\lstinputlisting[language=Java, label=JavaExample]{code/Example.java}
\renewcommand{\lstlistingname}{Листинг}
\lstinputlisting[caption=Описанное промежуточном представлении, language=Java, label=Shimple]{code/Example.shimp}

\drawfigurex{CFG.png}{CFG метода}{CFG}{0.55\textwidth}


\FloatBarrier
\section{Получение множества возможных блокировок}
Алгоритм должен быть точным, то есть сообщать только о тех полях, которые действительно корректно-синхронизированы.
В полученном в предыдущем разделе представлении операция взятия блокировки осуществляется с локальной переменной. 
При обходе графа, который будет рассмотрен в следующей главе нужно поддерживать текущее множество взятых блокировок.
Если нельзя статически доказать, что локальная переменная всегда ссылается на одно поле, или переменная ссылается на поле, которе может изменится, то операции взятия блокировки по таким переменным не должна добавлять информацию относително взятых блокировок.
В листинге \ref{PhiLock} демонстрируется соответсвующий пример.

\lstinputlisting[caption=Блокировка с несколькими возможными значениями, language=Java, label=PhiLock]{code/PhiLock.java}

В данном примере переменная $lock$ может ссылаться на поле $lock1$ и $lock2$. И куда будет ссылаться $lock$ статическим анализом выяснить нельзя. Таким образом, операция  синхронизации не должна изменять множество взятых блокировок.

\subsection{Нахождение переменных, которые могут ссылаться на разные поля}
В данном разделе будет показано, как найти все локальные переменные, которые могут иметь не единственное значение.
Так как полученое представление является SSA, то каждая переменная имеет единственное место инициализации. 
Если переменная инициализируется как $\phi$-функция, то значит эта переменная может иметь не единственное значеие. Также если локальная переменная $l1$ присваивается другой локальной переменной $l2$, или полю локальной переменной $l2.field$, и $l2$ может иметь не единственное значение, то $l1$ может иметь не единственно значение и не может являться блокировкой.

Алгоритм будет следующим. Сначала выделим множество переменных, которые инициализуются $\phi$-функциями. Затем построим замыкание данного множества относительно операций присваивания. Полученное множество, очевидно будет искомым.

\subsection{Нахождение переменных, ссылающихся на не final поля}
\lstinputlisting[caption=Блокировка по полю другого класса, language=Java, label=FinalLockA]{code/FinalLockA.java}

В листинге \ref{FinalLockA} показан пример, когда берется блокировка по полю другого класса. 
Чтобы являться блокировкой, поле $b$ класса $A$ должно иметь модификатор $final$ и поле $lock$ класса $B$ также должно быть $final$. В общем случае каждое поле в пути блокировки должно иметь модификатор $final$. Отметим, что данные рассуждения относятся к не $static$ полям. В случае со $static$ полями достаточно проверить, что поле имеет модификатор $final$.

Алгоритм будет следующим. Сначала выделим множество переменных, которые ссылаются на не $final$ поля. Затем построим замыкание данного множества относительно операций присваивания. Полученное множество, очевидно будет искомым.

\section{Обход графа потока исполнения}
В данной главе будет рассмотрен алгоритм обхода $CFG$ каждого метода. Описан сам обход, обработка операций сихронизации и обращения к полям. 

Обход будет рекурсивным, напоминающий обход в глубину, но с некоторыми отличиями. При обходе будем поддерживать множество текущих взятых блокировок $curLocks$. Также для каждой вершины $CFG$ будем сохранять множество блокировок, с которыми обход уже посещал данную вершину $v.locks$.
При входе в вершину $v$ нужно сравнить $curLocks$ и $v.locks$. Если $v.locks \subseteq curLocks$, то можно не продолжать обход вершины $v$. Если $v.locks \nsubseteq curLocks$, то в $v.locks$ и $curLocks$ запишем  $v.locks \cap curLocks$ и продолжим обход. Записывать нужно пересечение, так как если существует ветка обхода, в которой вершина $v$ посещена без блокировки $l$, то нельзя гарантировать, что операция вершины $v$ защищена блокировкой $l$. 

Изменять $curLocks$ будем при операциях взятия и освобождения блокировки. Для каждого поля будем хранить, множество блокировок, с которыми обращались к данному полю $f.locks$. При обращениии к полю $f$, будем также пересекать $f.locks$ и 
$currentLocks$.
Далее приведен псевдокод описанного алгоритма.

\begin{algorithm}
\caption{Алгоритм обхода $CFG$ метода}\label{alg:TraverseCFG}
\begin{algorithmic}
\Function{visit}{CFGVertex v,  Set<Lock> currentLocks}
\If {v.locks $\subseteq$ currentLocks}
	\State break
\Else
	\State v.locks $\gets$ v.locks $\cap$ currentLocks 
	\State currentLocks $\gets$ v.locks $\cap$ currentLocks 
\EndIf
\State op $\gets$ v.getOperation()
\If {op.isMonitorEnterOperation()}
	\State currentLocks.add(v.getOperations.getLock())
\EndIf
\If {op.isMonitorExitOperation()}
	\State currentLocks.remove(v.getOperations.getLock())
\EndIf

\If {op.isFieldAssignmentOperation()}
	\State field $\gets$ op.getField()
	\State field.locks $\gets$ field.locks $\cap$ currentLocks
\EndIf

\ForAll{CFGVertex c : v.childs}
	\State \Call {visit}{c, currentLocks}
\EndFor

\EndFunction
 
\end{algorithmic}
\end{algorithm}

\FloatBarrier

Далее будет более подробно рассмотренна обработка операций синхронизации и обращения к полям.

\subsection{Обработка операций синхронизации}
Если при обходе встретилась операция синхронизации, то нужно изменить $currentLocks$. Но сначала нужно проверить, что переменная, над которой осуществляется операция синхронизации может являться блокировкой. Данная проверка описана в предыдущем разделе. Далее, если текущая операция --- операция взятия блокировки, то добавить блокировку в $currentLocks$, 
если операция освобождения, то удалить блокировку из $currentLocks$. Помимо стандартных операций $monitorEnter$ и $monitorExit$ в данной работе рассмотрены блокировки пакета java.util.concurent и их парные операции $lock()$ и $unlock()$.

\subsection{Обработка операции обращения к полям}
При обращении к полю может возникнуть состояние гонки. Но, если существует блокировка $l$, такая что любая операция чтения  и записи с полем $v$ производится со взятой $l$, то поле $v$ корректно-синхронизировано. Таким образом, для каждого поля $f$ надо поддерживать множество блокировок $f.locks$, с которыми гарантировано обращались к данному полю. А при обращении к полю $f$ сужать $f.locks$ до пересечения $f.locks$ и $currentLocks$. 


\FloatBarrier
