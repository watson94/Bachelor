%-*-coding: utf-8-*-
\chapter{Описание алгоритма}


В данной главе будет рассмотрен алгоритм для поиска корректно-синхронизированных полей.
Поле является корректно-синхронизированным, когда существует блокировка, такая, что любая операция c полем проводится с этой блокировкой. Алгоритм будет искать для полей, такие блокировки. 
Алгоритм можно разделить на 3 части. 
\begin{enumerate}
\item Восстановление графа потока исполнения.
\item Получение множества возможных блокировок.
\item Обход графа потока исполнения и выделение корректно-синхронизированных полей.
\end{enumerate}

В первой главе будет рассмотренно промежуточное представление, на основе которого будет строиться граф потока исполнения. Во второй показано как выделить множество переменных, которые могут являться блокировкой. Эта часть алгоритма необходима, так как при статическом анализе не каждая локальная переменная и не каждое поле может являться потенциальной блокировкой. 
В третей части будет рассмотрена основная часть алгоритма --- обход графа потока исполнения, отслеживание и обработка и операций сихронизаций и обращений к полям, выделение корректно-синхронизированных полей.



\FloatBarrier
\section{Получение графа потока управления}


\FloatBarrier
\section{Получение множества возможных блокировок}
Алгоритм должен быть точным, то есть сообщать только о тех полях, которые действительно корректно-синхронизированы.
В полученном в предыдущем разделе представлении операция взятия блокировки осуществляется с локальной переменной. 
При обходе графа, который будет рассмотрен в следующей главе нужно поддерживать текущее множество взятых блокировок.
Если нельзя статически доказать, что локальная переменная всегда ссылается на одно поле, или переменная ссылается на поле, которе может изменится, то операции взятия блокировки по таким переменным не должна добавлять информацию относително взятых блокировок.
В листинге \ref{PhiLock} демонстрируется соответсвующий пример.

\lstinputlisting[caption=Mycaption, language=Java, label=PhiLock]{code/PhiLock.java}

В данном примере переменная $lock$ может ссылаться на поле $lock1$ и $lock2$. И куда будет ссылаться $lock$ статическим анализом выяснить нельзя. Таким образом, дальнейшая операция  синхронизации не должна изменять множество взятых блокировок.

\subsection{Нахождение переменных, которые могут ссылаться на разные поля}
В данном разделе будет показано, как найти все локальные переменные, которые могут иметь не единственное значение.
Так как полученое представление является SSA, то каждая переменная имеет единственное место инициализации. 
Если переменная инициализируется как $phi-node$, то значит эта переменная может иметь не единственное значеие. Также если локальная переменная $l1$ присваивается другой локальной переменной $l2$, или полю локальной переменной $l2.field$, и $l2$ может иметь не единственное значение, то $l1$ может иметь не единственно значение и не может являться блокировкой.

Алгоритм будет следующим. Сначала выделим множество переменных, которые инициализуются $phi$-$node$. Затем построим замыкание данного множества относительно операций присваивания, описанных выше. Полученное множество, очевидно будет искомым.

\subsection{Нахождение переменных, ссылающихся на не final поля}
\lstinputlisting[caption=Mycaption1, language=Java, label=FinalLockA]{code/FinalLockA.java}

В листинге \ref{FinalLockA} показан пример, когда берется блокировка по полю другого класса. 
Чтобы являться блокировкой поле $b$ класса A должно иметь модификатор final и поле $lock$ класса $B$ также должно быть final. В общем случае каждое поле в пути блокировки должно иметь модификатор $final$. Отметим, что данные рассуждения относятся к $non-static$ полям. В случае со $static$ полями достаточно проверить, что поле имеет модификатор $final$.

Алгоритм будет следующим. Сначала выделим множество переменных, которые инициализуются ссылаются на $non-final$ поля. Затем построим замыкание данного множества относительно операций свзязывания, описанных выше. Полученное множество, очевидно будет искомым.

\section{Обход графа потока исполнения}
В данной главе будет рассмотрен алгоритм обхода $CFG$ каждого метода. Описан сам обход, обработка операций сихронизации и обращения к полям. 

Обход будет рекурсивным, напоминающий обход в глубину, но с некоторыми отличиями. При обходе будем поддерживать множество текущих взятых блокировок $curLocks$. Также для каждой вершины CFG будем сохранять множество блокировок, с которыми обход уже посещал данную вершину $v.locks$.
При входе в вершину $v$ нужно сравнить $curLocks$ и $v.locks$. Если $v.locks \subseteq curLocks$, то можно не продолжать обход вершины $v$. Если $v.locks \nsubseteq curLocks$, то в $v.locks$ и $curLocks$ запишем  $v.locks \cap curLocks$ и продолжим обход. Записывать нужно пересечение, так как если существует ветка обхода, в которой вершина $v$ посещена без блокировки $l$, то нельзя гарантировать, что операция вершины $v$ защищена блокировкой $l$. 

Изменять $curLocks$ будем при операциях взятия и отпускания блокировки. Для каждого поля будем хранить, множество блокировок, с которыми обращались к данному полю $f.locks$. При обращениии к полю $f$, будем также пересекать $f.locks$ и 
$currentLocks$.
Далее приведен псевдокод описанного алгоритма.

\begin{algorithm}
\caption{Алгоритм обхода $CFG$ метода}\label{alg:TraverseCFG}
\begin{algorithmic}
\Function{visit}{CFGVertex v,  Set<Lock> currentLocks}
\If {v.locks $\subseteq$ currentLocks}
	\State v.locks $\gets$ v.locks $\cap$ currentLocks 
	\State currentLocks $\gets$ v.locks $\cap$ currentLocks 
\EndIf
\State op $\gets$ v.getOperation()
\If {op.isMonitorEnterOperation()}
	\State currentLocks.add(v.getOperations.getLock())
\EndIf
\If {op.isMonitorExitOperation()}
	\State currentLocks.remove(v.getOperations.getLock())
\EndIf

\If {op.isFieldAssignmentOperation()}
	\State field $\gets$ op.getField()
	\State field.locks $\gets$ field.locks $\cap$ currentLocks
\EndIf

\ForAll{c : v.childs}
	\State \Call {visit}{c, currentLocks}
\EndFor

\EndFunction
 
\end{algorithmic}
\end{algorithm}

\FloatBarrier

Далее будет более подробно рассмотренна обработка операций синхронизации и обращения к полям.

\subsection{Обработка операций синхронизации}
Если при обходе встретилась операция синхронизации, то нужно изменить $currentLocks$. Но сначала нужно проверить, что переменная, над которой осуществляется операция синхронизации может являться блокировкой. Данная проверка описана в предыдущем разделе. Далее, если текущая операция --- операция взятия блокировки, то добавить блокировку в $currentLocks$, 
если операция отпускания, то удалить блокировку из $currentLocks$. Помимо стандартных операций $monitorEnter$ и $monitorExit$ в данной работе рассмотрены блокировки пакета java.util.concurent и их парные операции $lock()$ и $unlock()$.

\subsection{Обработка операции обращения к полям}
При обращении к полю нужно 


\FloatBarrier
