%-*-coding: utf-8-*-
\chapter{Практическая реализация алгоритма}

В рамках данной работы была написана программа для поиска корректно-синхронизированных полей, использующая алгоритм из предыдущего раздела. Программа написана на языке программирования java и интегрирована с jDRD.

\FloatBarrier
\section{Особенности реализации}
Данная программа имеет два режима работы: \emph{локальный} и \emph{глобальный}. \emph{Локальный} режим подразумевает, что анализируемый код
может использоваться сторонними приложениями, не входящими в область анализа. Таким образом, если поле корректно-синхронизировано в рамках анализируемой программы, но оно доступно для изменения, то в локальном режиме оно не считается корректно-синхронизированным. Такой режим нужен для анализа различных библиотек. \emph{Глобальный} режим подразумевает, что 
анализируемый код используется только из области анализа. Если поле корректно-синхронизировано в рамках анализируемой программы, то даже если оно доступно для изменения, глобальный режим отметит его как корректно-синхронизированное. Данный режим необходим для тестирования законченных приложений. Множество переменных, выделенное в глобальном режиме включает в себя множество, выделенное при работе в локальном режиме.



В листинге \ref{Account} поле $balance$ корректно-синхронизировано, и будет выделено при работе программы и в локальном, и в глобальном режиме. Если убрать модификатор $private$ у поля $balance$ и предположить, что в рамках программы снаружи к полю $balance$ не обращаются, то оно будет корректно-синхронизировано только с точки зрения глобального режима.

\lstinputlisting[caption=Пример корректно-синхронизированного поля для локального режима., language=Java, label=Account]{code/Account.java}

Программа на вход принимает скомпилированные файлы java-программ. На вход ей можно подать либо $jar$-файл с программой, либо указать путь до папки с $class$-файлами.  Промежуточное представление и граф потока исполнения получены на основе байт-кода с помощью библиотеки $Soot$\cite{SootPage}. Промежуточное представление, используемое в данной работе для анализа, называется $Shimple$\cite{Soot}.


\FloatBarrier
\section{Тестирование}
Было проведено тестирование разработанной программы на различных тестах. Создан набор тестов, покрывающий большинство конструкций java-программ. В качестве тестов были использованы программы использующие различные операции синхронизации, обработку ошибок(exception), статические и нестатические блокировки и поля, внутренние классы и т.д.

Также были проведены запуски на реальных библиотеках и приложениях с последующей проверкой результатов.

\FloatBarrier
\section{Сбор статистики и интеграция с jDRD}
В программу статического анализа был добавлен модуль сбора статистики, который подсчитывает различные метрики работы алгоритма. Этот модуль необходим для оценки результата работы программы.

jDRD получает список корректно-синхронизированных полей через конфигурационный файл, генерируемый разработанной программой.
В jDRD был также включен сбор статистики, который отслеживает количество обращений к корректно-синхронизированным полям, выделенным статическим анализом.


\section{Полученные результаты}
Программа была запущена на различных приложениях, которые активно используют конкурентный доступ к данным .  Результаты приведены в таблице. 

\begin{table}[H]
\label{results}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Приложение & Общее количество полей & Корректно-синхронизированных полей & Процент \\
\hline
dxFeed & 5730 & 493 & 8,6 \\
\hline
MARS & 4437 & 340 & 7,6 \\
\hline
Tomcat & 7600 & 390 & 5,1 \\

\hline

\end{tabular}
\captionsetup{justification=centering}
\caption{Полученные результаты}
\end{center}
\end{table}
Далее представлено краткое описание тестируемых библиотек.
\\MARS(Monitoring and reporting system) --- Система мониторинга реального времени. Используется для отображения различных данных приложения. 
\\ dxFeed --- система, отвечающая за быструю доставку больших данных(котировок).
\\ Tomcat --- контейнер сервлетов. Позволяет запускать веб-приложения.

По результатам видно, что для данных библиотек  в среднем статическим анализом можно удалось около 6\%, что является  хорошим результатом. Причем статистика, собранная динамическим детектором подтвердила, что данные поля используются.

Далее приведены найденные часто используемые паттерны, применяемые для защиты блокировкой операций блокировкой.
\\
\\

\lstinputlisting[caption=Использование synchronized методов, language=Java, label=Pattern1]{code/Pattern1.java}
\lstinputlisting[caption=Использование блокировки для синхронизации, language=Java, label=Pattern2]{code/Pattern2.java}
\lstinputlisting[caption=Использование блокировки для синхронизации, language=Java, label=Pattern3]{code/Pattern3.java}

\FloatBarrier
